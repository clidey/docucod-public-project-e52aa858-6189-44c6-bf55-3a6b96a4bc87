---
title: "Who Should Use It? Key Use Cases"
description: "Identify the ideal users for GORM Data Types: application developers leveraging Go and GORM for relational data storage, teams standardizing data types across environments, and anyone needing advanced features like JSON columns or UUID primary keys. Browse typical usage scenarios, from auditing metadata to dynamic configuration storage and user profile modeling."
---

# Who Should Use It? Key Use Cases

Unlock the full potential of your GORM-based Go applications by leveraging GORM Data Types. This page identifies the ideal users and highlights real-world scenarios where integrating advanced SQL data types like JSON, UUID, and custom Date types dramatically improves data modeling, querying, and maintenance.

---

## Who Benefits Most from GORM Data Types?

### Application Developers Using Go and GORM
If you're writing applications with Go and using the GORM ORM, this library extends your capabilities far beyond basic types. By incorporating the GORM Data Types package, you can effortlessly model complex data structures such as JSON objects directly in your database columns, uniquely identify records with UUIDs, or handle dates and times with precision and consistency.

### Teams Standardizing Data Handling Across Multiple Environments
For organizations managing applications that run on multiple databases—MySQL, PostgreSQL, SQLite, or SQL Server—GORM Data Types offers a unified, type-safe abstraction. This removes the hassle of writing divergent SQL or application logic by harmonizing how advanced data types behave across environments.

### Developers Needing Advanced Features Out-of-the-Box
Whether it’s storing flexible metadata, supporting rich user profiles, or managing session tokens, GORM Data Types provides essential building blocks:
- JSON columns for dynamic, schema-less attributes
- UUID support for globally unique, collision-resistant identifiers
- Date and Time types that respect database-specific formats

---

## Typical Usage Scenarios

### 1. Auditing and Metadata Storage
Use JSON columns to store varying audit information or metadata alongside core relational data without schema changes. For example, logging user action details, preferences, or nested configurations inside a single JSON field.

```go
import "gorm.io/datatypes"

type AuditLog struct {
    gorm.Model
    Action     string
    Parameters datatypes.JSON
}

log := AuditLog{
    Action: "UpdateProfile",
    Parameters: datatypes.JSON([]byte(`{"ip": "192.168.1.50", "device": "mobile"}`)),
}
DB.Create(&log)
```

### 2. Modeling User Profiles with Flexible Attributes
Use `JSONType[T]` or `JSONSlice[T]` to model structured but flexible user profile data, allowing applications to evolve without complex schema migrations.

```go
import "gorm.io/datatypes"

type ProfileAttributes struct {
    Age  int
    Tags []string
}

type User struct {
    gorm.Model
    Name       string
    Attributes datatypes.JSONType[ProfileAttributes]
}

user := User{
    Name: "Alice",
    Attributes: datatypes.NewJSONType(ProfileAttributes{Age: 25, Tags: []string{"golang", "developer"}}),
}
DB.Create(&user)
```

### 3. Leveraging UUIDs for Primary Keys or Unique Fields
Generate and store UUIDs as primary keys or unique identifiers, especially useful in distributed systems or when you need to avoid auto-increment collisions.

```go
import "gorm.io/datatypes"

userUUID := datatypes.NewUUIDv4()

user := UserWithUUID{
    Name:     "bob",
    UserUUID: userUUID,
}
DB.Create(&user)
```

### 4. Dynamic Configuration Storage
Store configuration arrays or complex nested values inside JSON or JSONB columns while allowing efficient querying and atomic updates.

### 5. Cross-Database Compatibility
Maintain consistent semantics for JSON, Date, and UUID fields across different SQL databases. GORM Data Types abstracts dialect differences, enabling seamless app portability.

---

## Why Should You Care?

- **Simplify Complex Models:** Write less migration code by nesting flexible JSON objects or arrays inside your models.
- **Improve Query Expressiveness:** Use built-in JSON query helpers to filter and search JSON fields without manual SQL.
- **Reduce Cross-Environment Bugs:** Handle UUID formats, date types, and JSON serialization uniformly across databases.
- **Optimize Development Speed:** Focus on feature development instead of writing database-specific type adapters or parsers.

---

## Practical Tips and Best Practices

- Always define your JSON structures clearly when using `JSONType[T]` for typed safety and cleaner code.
- Combine GORM’s querying features with JSON query helpers to leverage database-native JSON functions.
- Use UUIDs generated by the library methods (`NewUUIDv1`, `NewUUIDv4`) to ensure correct formatting and uniqueness.
- For storing dates, prefer the `Date` type from the package to avoid common pitfalls with time zones and date truncation.

---

## Next Steps

- Explore the [What is GORM Data Types?](/overview/introduction-value/what-is-gorm-datatypes) page for foundational knowledge.
- Review [Feature Highlights](/overview/feature-preview/feature-highlights) to understand all capabilities.
- Begin with setting up your project via [Install GORM Data Types](/getting-started/setup-basics/install-gorm-datatypes).

---

## Additional Resources
- [JSON Query Helpers](#/api-reference/advanced-operations/json-query-helpers) to perform powerful queries on JSON columns.
- [UUID Integration Guide](#/guides/core-data-types/uuid-integration) for best practices using UUIDs.
- [Atomic JSON Updates](#/guides/advanced-json-patterns/atomic-json-update) for safe in-place JSON field mutations.

---

Understanding your user needs is key to unlocking GORM Data Types' full power. With this foundation, you’re ready to model your data more expressively and maintainably than ever before.